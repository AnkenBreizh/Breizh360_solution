using System.Threading.RateLimiting;
using Breizh360.Gateway.Auth;
using Breizh360.Gateway.Errors;
using Breizh360.Gateway.Observability;
using Microsoft.AspNetCore.HttpOverrides;
using Yarp.ReverseProxy.Transforms;

var builder = WebApplication.CreateBuilder(args);

// Logs
builder.Logging.ClearProviders();
builder.Logging.AddConsole();

// Forwarded headers (IIS / reverse proxy). Safe defaults for intranet.
builder.Services.Configure<ForwardedHeadersOptions>(options =>
{
    options.ForwardedHeaders = ForwardedHeaders.XForwardedFor | ForwardedHeaders.XForwardedProto;
    // NOTE: in intranet, you can lock down KnownNetworks/KnownProxies if needed.
});

// CORS centralisé
builder.Services.AddCors(options =>
{
    options.AddPolicy("gateway-cors", policy =>
    {
        var origins = builder.Configuration.GetSection("Gateway:Cors:AllowedOrigins").Get<string[]>() ?? Array.Empty<string>();

        if (origins.Length == 0)
        {
            // Dev fallback: allow credentials + dynamic origin (no wildcard)
            policy.SetIsOriginAllowed(_ => true);
        }
        else
        {
            policy.WithOrigins(origins);
        }

        policy.AllowAnyHeader()
              .AllowAnyMethod()
              .AllowCredentials();
    });
});

// Rate limiting (partition by client IP) — tune via appsettings
builder.Services.AddRateLimiter(options =>
{
    var permitLimit = builder.Configuration.GetValue<int?>("Gateway:RateLimiting:PermitLimit") ?? 200;
    var windowSeconds = builder.Configuration.GetValue<int?>("Gateway:RateLimiting:WindowSeconds") ?? 60;

    options.AddPolicy("gw-fixed", httpContext =>
    {
        var ip = httpContext.Connection.RemoteIpAddress?.ToString() ?? "unknown";
        return RateLimitPartition.GetFixedWindowLimiter(ip, _ => new FixedWindowRateLimiterOptions
        {
            PermitLimit = permitLimit,
            Window = TimeSpan.FromSeconds(windowSeconds),
            QueueLimit = 0,
            QueueProcessingOrder = QueueProcessingOrder.OldestFirst,
            AutoReplenishment = true
        });
    });

    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
});

// Reverse proxy (YARP) — /api/* and /hubs/* -> API
builder.Services
    .AddReverseProxy()
    .LoadFromConfig(builder.Configuration.GetSection("ReverseProxy"))
    .AddTransforms(transforms =>
    {
        // Always propagate X-Correlation-ID to the downstream API
        transforms.AddRequestTransform(ctx =>
        {
            if (ctx.HttpContext.Request.Headers.TryGetValue(GatewayCorrelationIdMiddleware.HeaderName, out var cid))
            {
                ctx.ProxyRequest.Headers.Remove(GatewayCorrelationIdMiddleware.HeaderName);
                ctx.ProxyRequest.Headers.TryAddWithoutValidation(GatewayCorrelationIdMiddleware.HeaderName, (string)cid);
            }
            return ValueTask.CompletedTask;
        });
    });

var app = builder.Build();

app.UseForwardedHeaders();

// Emit/propagate correlation id as early as possible
app.UseMiddleware<GatewayCorrelationIdMiddleware>();

// Normalize errors generated by the Gateway itself
app.UseMiddleware<GatewayErrorMiddleware>();

app.UseHttpsRedirection();

app.UseCors("gateway-cors");

app.UseRateLimiter();

// Presence/format check only — API remains the source of authority for JWT validation.
app.UseMiddleware<GatewayJwtForwardingMiddleware>();

app.MapGet("/health", (HttpContext ctx) =>
{
    return Results.Ok(new { status = "ok", correlationId = ctx.Response.Headers[GatewayCorrelationIdMiddleware.HeaderName].ToString() });
}).DisableRateLimiting();

// Apply rate limiting to proxy routes (global)
app.MapReverseProxy().RequireRateLimiting("gw-fixed");

app.Run();
